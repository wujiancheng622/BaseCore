// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MediaBean.proto

#ifndef PROTOBUF_MediaBean_2eproto__INCLUDED
#define PROTOBUF_MediaBean_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "DevInfoListBean.pb.h"
// @@protoc_insertion_point(includes)

namespace com {
namespace arges {
namespace file {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MediaBean_2eproto();
void protobuf_AssignDesc_MediaBean_2eproto();
void protobuf_ShutdownFile_MediaBean_2eproto();

class ReqMediaPlay;
class ReqTokenPair;
class RspTokenPair;

enum ACCESS_TYPE_OF_DEVICE {
  MOUNT_OF_DMS = 1,
  MOUNT_OF_BBOX = 2,
  MOUNT_OF_PROXY_SERVICE = 3
};
bool ACCESS_TYPE_OF_DEVICE_IsValid(int value);
const ACCESS_TYPE_OF_DEVICE ACCESS_TYPE_OF_DEVICE_MIN = MOUNT_OF_DMS;
const ACCESS_TYPE_OF_DEVICE ACCESS_TYPE_OF_DEVICE_MAX = MOUNT_OF_PROXY_SERVICE;
const int ACCESS_TYPE_OF_DEVICE_ARRAYSIZE = ACCESS_TYPE_OF_DEVICE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ACCESS_TYPE_OF_DEVICE_descriptor();
inline const ::std::string& ACCESS_TYPE_OF_DEVICE_Name(ACCESS_TYPE_OF_DEVICE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ACCESS_TYPE_OF_DEVICE_descriptor(), value);
}
inline bool ACCESS_TYPE_OF_DEVICE_Parse(
    const ::std::string& name, ACCESS_TYPE_OF_DEVICE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ACCESS_TYPE_OF_DEVICE>(
    ACCESS_TYPE_OF_DEVICE_descriptor(), name, value);
}
enum STREAM_TYPE_OF_MEDIA {
  STREAM_TYPE_OF_MAIN = 1,
  STREAM_TYPE_OF_SUB = 2
};
bool STREAM_TYPE_OF_MEDIA_IsValid(int value);
const STREAM_TYPE_OF_MEDIA STREAM_TYPE_OF_MEDIA_MIN = STREAM_TYPE_OF_MAIN;
const STREAM_TYPE_OF_MEDIA STREAM_TYPE_OF_MEDIA_MAX = STREAM_TYPE_OF_SUB;
const int STREAM_TYPE_OF_MEDIA_ARRAYSIZE = STREAM_TYPE_OF_MEDIA_MAX + 1;

const ::google::protobuf::EnumDescriptor* STREAM_TYPE_OF_MEDIA_descriptor();
inline const ::std::string& STREAM_TYPE_OF_MEDIA_Name(STREAM_TYPE_OF_MEDIA value) {
  return ::google::protobuf::internal::NameOfEnum(
    STREAM_TYPE_OF_MEDIA_descriptor(), value);
}
inline bool STREAM_TYPE_OF_MEDIA_Parse(
    const ::std::string& name, STREAM_TYPE_OF_MEDIA* value) {
  return ::google::protobuf::internal::ParseNamedEnum<STREAM_TYPE_OF_MEDIA>(
    STREAM_TYPE_OF_MEDIA_descriptor(), name, value);
}
enum REQUEST_TYPE_OF_MEIDA {
  MEDIA_REQUEST = 1,
  MEIDA_REQUEST_FOR_DEVICE = 2,
  MEDIA_RESPONSE_FOR_DEVICE = 3
};
bool REQUEST_TYPE_OF_MEIDA_IsValid(int value);
const REQUEST_TYPE_OF_MEIDA REQUEST_TYPE_OF_MEIDA_MIN = MEDIA_REQUEST;
const REQUEST_TYPE_OF_MEIDA REQUEST_TYPE_OF_MEIDA_MAX = MEDIA_RESPONSE_FOR_DEVICE;
const int REQUEST_TYPE_OF_MEIDA_ARRAYSIZE = REQUEST_TYPE_OF_MEIDA_MAX + 1;

const ::google::protobuf::EnumDescriptor* REQUEST_TYPE_OF_MEIDA_descriptor();
inline const ::std::string& REQUEST_TYPE_OF_MEIDA_Name(REQUEST_TYPE_OF_MEIDA value) {
  return ::google::protobuf::internal::NameOfEnum(
    REQUEST_TYPE_OF_MEIDA_descriptor(), value);
}
inline bool REQUEST_TYPE_OF_MEIDA_Parse(
    const ::std::string& name, REQUEST_TYPE_OF_MEIDA* value) {
  return ::google::protobuf::internal::ParseNamedEnum<REQUEST_TYPE_OF_MEIDA>(
    REQUEST_TYPE_OF_MEIDA_descriptor(), name, value);
}
enum RESULT_TYPE_OF_MEDIA {
  MEDIA_RESULT_GET_TOKEN_TRUE = 1,
  MEDIA_RESULT_GET_TOKEN_ERROR = 2,
  MEDIA_RESULT_GET_DEVICE_TRUE = 3,
  MEDIA_RESULT_GET_DEVICE_ERROR = 4
};
bool RESULT_TYPE_OF_MEDIA_IsValid(int value);
const RESULT_TYPE_OF_MEDIA RESULT_TYPE_OF_MEDIA_MIN = MEDIA_RESULT_GET_TOKEN_TRUE;
const RESULT_TYPE_OF_MEDIA RESULT_TYPE_OF_MEDIA_MAX = MEDIA_RESULT_GET_DEVICE_ERROR;
const int RESULT_TYPE_OF_MEDIA_ARRAYSIZE = RESULT_TYPE_OF_MEDIA_MAX + 1;

const ::google::protobuf::EnumDescriptor* RESULT_TYPE_OF_MEDIA_descriptor();
inline const ::std::string& RESULT_TYPE_OF_MEDIA_Name(RESULT_TYPE_OF_MEDIA value) {
  return ::google::protobuf::internal::NameOfEnum(
    RESULT_TYPE_OF_MEDIA_descriptor(), value);
}
inline bool RESULT_TYPE_OF_MEDIA_Parse(
    const ::std::string& name, RESULT_TYPE_OF_MEDIA* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RESULT_TYPE_OF_MEDIA>(
    RESULT_TYPE_OF_MEDIA_descriptor(), name, value);
}
enum OPRATE_TYPE_OF_MEDIA {
  START_TO_PLAY_MEDIA = 1,
  STOP_TO_PLAY_MEDIA = 2,
  START_TO_RECEIVE_SCANNER = 3,
  STOP_TO_RECEIVE_SCANNER = 4
};
bool OPRATE_TYPE_OF_MEDIA_IsValid(int value);
const OPRATE_TYPE_OF_MEDIA OPRATE_TYPE_OF_MEDIA_MIN = START_TO_PLAY_MEDIA;
const OPRATE_TYPE_OF_MEDIA OPRATE_TYPE_OF_MEDIA_MAX = STOP_TO_RECEIVE_SCANNER;
const int OPRATE_TYPE_OF_MEDIA_ARRAYSIZE = OPRATE_TYPE_OF_MEDIA_MAX + 1;

const ::google::protobuf::EnumDescriptor* OPRATE_TYPE_OF_MEDIA_descriptor();
inline const ::std::string& OPRATE_TYPE_OF_MEDIA_Name(OPRATE_TYPE_OF_MEDIA value) {
  return ::google::protobuf::internal::NameOfEnum(
    OPRATE_TYPE_OF_MEDIA_descriptor(), value);
}
inline bool OPRATE_TYPE_OF_MEDIA_Parse(
    const ::std::string& name, OPRATE_TYPE_OF_MEDIA* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OPRATE_TYPE_OF_MEDIA>(
    OPRATE_TYPE_OF_MEDIA_descriptor(), name, value);
}
// ===================================================================

class ReqMediaPlay : public ::google::protobuf::Message {
 public:
  ReqMediaPlay();
  virtual ~ReqMediaPlay();

  ReqMediaPlay(const ReqMediaPlay& from);

  inline ReqMediaPlay& operator=(const ReqMediaPlay& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqMediaPlay& default_instance();

  void Swap(ReqMediaPlay* other);

  // implements Message ----------------------------------------------

  ReqMediaPlay* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqMediaPlay& from);
  void MergeFrom(const ReqMediaPlay& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 requestType = 1 [default = -1];
  inline bool has_requesttype() const;
  inline void clear_requesttype();
  static const int kRequestTypeFieldNumber = 1;
  inline ::google::protobuf::int32 requesttype() const;
  inline void set_requesttype(::google::protobuf::int32 value);

  // optional string channelId = 2 [default = ""];
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIdFieldNumber = 2;
  inline const ::std::string& channelid() const;
  inline void set_channelid(const ::std::string& value);
  inline void set_channelid(const char* value);
  inline void set_channelid(const char* value, size_t size);
  inline ::std::string* mutable_channelid();
  inline ::std::string* release_channelid();
  inline void set_allocated_channelid(::std::string* channelid);

  // optional int32 streamType = 3 [default = 1];
  inline bool has_streamtype() const;
  inline void clear_streamtype();
  static const int kStreamTypeFieldNumber = 3;
  inline ::google::protobuf::int32 streamtype() const;
  inline void set_streamtype(::google::protobuf::int32 value);

  // optional .com.arges.file.proto.DeviceInfo dev = 4;
  inline bool has_dev() const;
  inline void clear_dev();
  static const int kDevFieldNumber = 4;
  inline const ::com::arges::file::proto::DeviceInfo& dev() const;
  inline ::com::arges::file::proto::DeviceInfo* mutable_dev();
  inline ::com::arges::file::proto::DeviceInfo* release_dev();
  inline void set_allocated_dev(::com::arges::file::proto::DeviceInfo* dev);

  // optional string token = 5 [default = ""];
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 5;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional string ip = 6 [default = ""];
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 6;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 port = 7 [default = 0];
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 7;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional int32 result = 8 [default = -1];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 8;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional bytes resultDescribe = 9 [default = ""];
  inline bool has_resultdescribe() const;
  inline void clear_resultdescribe();
  static const int kResultDescribeFieldNumber = 9;
  inline const ::std::string& resultdescribe() const;
  inline void set_resultdescribe(const ::std::string& value);
  inline void set_resultdescribe(const char* value);
  inline void set_resultdescribe(const void* value, size_t size);
  inline ::std::string* mutable_resultdescribe();
  inline ::std::string* release_resultdescribe();
  inline void set_allocated_resultdescribe(::std::string* resultdescribe);

  // @@protoc_insertion_point(class_scope:com.arges.file.proto.ReqMediaPlay)
 private:
  inline void set_has_requesttype();
  inline void clear_has_requesttype();
  inline void set_has_channelid();
  inline void clear_has_channelid();
  inline void set_has_streamtype();
  inline void clear_has_streamtype();
  inline void set_has_dev();
  inline void clear_has_dev();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_resultdescribe();
  inline void clear_has_resultdescribe();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* channelid_;
  ::google::protobuf::int32 requesttype_;
  ::google::protobuf::int32 streamtype_;
  ::com::arges::file::proto::DeviceInfo* dev_;
  ::std::string* token_;
  ::std::string* ip_;
  ::google::protobuf::int32 port_;
  ::google::protobuf::int32 result_;
  ::std::string* resultdescribe_;
  friend void  protobuf_AddDesc_MediaBean_2eproto();
  friend void protobuf_AssignDesc_MediaBean_2eproto();
  friend void protobuf_ShutdownFile_MediaBean_2eproto();

  void InitAsDefaultInstance();
  static ReqMediaPlay* default_instance_;
};
// -------------------------------------------------------------------

class ReqTokenPair : public ::google::protobuf::Message {
 public:
  ReqTokenPair();
  virtual ~ReqTokenPair();

  ReqTokenPair(const ReqTokenPair& from);

  inline ReqTokenPair& operator=(const ReqTokenPair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqTokenPair& default_instance();

  void Swap(ReqTokenPair* other);

  // implements Message ----------------------------------------------

  ReqTokenPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqTokenPair& from);
  void MergeFrom(const ReqTokenPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string userdata = 1 [default = ""];
  inline bool has_userdata() const;
  inline void clear_userdata();
  static const int kUserdataFieldNumber = 1;
  inline const ::std::string& userdata() const;
  inline void set_userdata(const ::std::string& value);
  inline void set_userdata(const char* value);
  inline void set_userdata(const char* value, size_t size);
  inline ::std::string* mutable_userdata();
  inline ::std::string* release_userdata();
  inline void set_allocated_userdata(::std::string* userdata);

  // @@protoc_insertion_point(class_scope:com.arges.file.proto.ReqTokenPair)
 private:
  inline void set_has_userdata();
  inline void clear_has_userdata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* userdata_;
  friend void  protobuf_AddDesc_MediaBean_2eproto();
  friend void protobuf_AssignDesc_MediaBean_2eproto();
  friend void protobuf_ShutdownFile_MediaBean_2eproto();

  void InitAsDefaultInstance();
  static ReqTokenPair* default_instance_;
};
// -------------------------------------------------------------------

class RspTokenPair : public ::google::protobuf::Message {
 public:
  RspTokenPair();
  virtual ~RspTokenPair();

  RspTokenPair(const RspTokenPair& from);

  inline RspTokenPair& operator=(const RspTokenPair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RspTokenPair& default_instance();

  void Swap(RspTokenPair* other);

  // implements Message ----------------------------------------------

  RspTokenPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RspTokenPair& from);
  void MergeFrom(const RspTokenPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ip = 1 [default = ""];
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 port = 2 [default = -1];
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional string token1 = 3 [default = ""];
  inline bool has_token1() const;
  inline void clear_token1();
  static const int kToken1FieldNumber = 3;
  inline const ::std::string& token1() const;
  inline void set_token1(const ::std::string& value);
  inline void set_token1(const char* value);
  inline void set_token1(const char* value, size_t size);
  inline ::std::string* mutable_token1();
  inline ::std::string* release_token1();
  inline void set_allocated_token1(::std::string* token1);

  // optional string token2 = 4 [default = ""];
  inline bool has_token2() const;
  inline void clear_token2();
  static const int kToken2FieldNumber = 4;
  inline const ::std::string& token2() const;
  inline void set_token2(const ::std::string& value);
  inline void set_token2(const char* value);
  inline void set_token2(const char* value, size_t size);
  inline ::std::string* mutable_token2();
  inline ::std::string* release_token2();
  inline void set_allocated_token2(::std::string* token2);

  // optional int32 result = 5 [default = -1];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 5;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional string userdata = 6 [default = ""];
  inline bool has_userdata() const;
  inline void clear_userdata();
  static const int kUserdataFieldNumber = 6;
  inline const ::std::string& userdata() const;
  inline void set_userdata(const ::std::string& value);
  inline void set_userdata(const char* value);
  inline void set_userdata(const char* value, size_t size);
  inline ::std::string* mutable_userdata();
  inline ::std::string* release_userdata();
  inline void set_allocated_userdata(::std::string* userdata);

  // @@protoc_insertion_point(class_scope:com.arges.file.proto.RspTokenPair)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_token1();
  inline void clear_has_token1();
  inline void set_has_token2();
  inline void clear_has_token2();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_userdata();
  inline void clear_has_userdata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ip_;
  ::std::string* token1_;
  ::google::protobuf::int32 port_;
  ::google::protobuf::int32 result_;
  ::std::string* token2_;
  ::std::string* userdata_;
  friend void  protobuf_AddDesc_MediaBean_2eproto();
  friend void protobuf_AssignDesc_MediaBean_2eproto();
  friend void protobuf_ShutdownFile_MediaBean_2eproto();

  void InitAsDefaultInstance();
  static RspTokenPair* default_instance_;
};
// ===================================================================


// ===================================================================

// ReqMediaPlay

// optional int32 requestType = 1 [default = -1];
inline bool ReqMediaPlay::has_requesttype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqMediaPlay::set_has_requesttype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqMediaPlay::clear_has_requesttype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqMediaPlay::clear_requesttype() {
  requesttype_ = -1;
  clear_has_requesttype();
}
inline ::google::protobuf::int32 ReqMediaPlay::requesttype() const {
  // @@protoc_insertion_point(field_get:com.arges.file.proto.ReqMediaPlay.requestType)
  return requesttype_;
}
inline void ReqMediaPlay::set_requesttype(::google::protobuf::int32 value) {
  set_has_requesttype();
  requesttype_ = value;
  // @@protoc_insertion_point(field_set:com.arges.file.proto.ReqMediaPlay.requestType)
}

// optional string channelId = 2 [default = ""];
inline bool ReqMediaPlay::has_channelid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqMediaPlay::set_has_channelid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqMediaPlay::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqMediaPlay::clear_channelid() {
  if (channelid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channelid_->clear();
  }
  clear_has_channelid();
}
inline const ::std::string& ReqMediaPlay::channelid() const {
  // @@protoc_insertion_point(field_get:com.arges.file.proto.ReqMediaPlay.channelId)
  return *channelid_;
}
inline void ReqMediaPlay::set_channelid(const ::std::string& value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
  // @@protoc_insertion_point(field_set:com.arges.file.proto.ReqMediaPlay.channelId)
}
inline void ReqMediaPlay::set_channelid(const char* value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.arges.file.proto.ReqMediaPlay.channelId)
}
inline void ReqMediaPlay::set_channelid(const char* value, size_t size) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.arges.file.proto.ReqMediaPlay.channelId)
}
inline ::std::string* ReqMediaPlay::mutable_channelid() {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channelid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.arges.file.proto.ReqMediaPlay.channelId)
  return channelid_;
}
inline ::std::string* ReqMediaPlay::release_channelid() {
  clear_has_channelid();
  if (channelid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = channelid_;
    channelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReqMediaPlay::set_allocated_channelid(::std::string* channelid) {
  if (channelid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete channelid_;
  }
  if (channelid) {
    set_has_channelid();
    channelid_ = channelid;
  } else {
    clear_has_channelid();
    channelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.arges.file.proto.ReqMediaPlay.channelId)
}

// optional int32 streamType = 3 [default = 1];
inline bool ReqMediaPlay::has_streamtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqMediaPlay::set_has_streamtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqMediaPlay::clear_has_streamtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqMediaPlay::clear_streamtype() {
  streamtype_ = 1;
  clear_has_streamtype();
}
inline ::google::protobuf::int32 ReqMediaPlay::streamtype() const {
  // @@protoc_insertion_point(field_get:com.arges.file.proto.ReqMediaPlay.streamType)
  return streamtype_;
}
inline void ReqMediaPlay::set_streamtype(::google::protobuf::int32 value) {
  set_has_streamtype();
  streamtype_ = value;
  // @@protoc_insertion_point(field_set:com.arges.file.proto.ReqMediaPlay.streamType)
}

// optional .com.arges.file.proto.DeviceInfo dev = 4;
inline bool ReqMediaPlay::has_dev() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqMediaPlay::set_has_dev() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqMediaPlay::clear_has_dev() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqMediaPlay::clear_dev() {
  if (dev_ != NULL) dev_->::com::arges::file::proto::DeviceInfo::Clear();
  clear_has_dev();
}
inline const ::com::arges::file::proto::DeviceInfo& ReqMediaPlay::dev() const {
  // @@protoc_insertion_point(field_get:com.arges.file.proto.ReqMediaPlay.dev)
  return dev_ != NULL ? *dev_ : *default_instance_->dev_;
}
inline ::com::arges::file::proto::DeviceInfo* ReqMediaPlay::mutable_dev() {
  set_has_dev();
  if (dev_ == NULL) dev_ = new ::com::arges::file::proto::DeviceInfo;
  // @@protoc_insertion_point(field_mutable:com.arges.file.proto.ReqMediaPlay.dev)
  return dev_;
}
inline ::com::arges::file::proto::DeviceInfo* ReqMediaPlay::release_dev() {
  clear_has_dev();
  ::com::arges::file::proto::DeviceInfo* temp = dev_;
  dev_ = NULL;
  return temp;
}
inline void ReqMediaPlay::set_allocated_dev(::com::arges::file::proto::DeviceInfo* dev) {
  delete dev_;
  dev_ = dev;
  if (dev) {
    set_has_dev();
  } else {
    clear_has_dev();
  }
  // @@protoc_insertion_point(field_set_allocated:com.arges.file.proto.ReqMediaPlay.dev)
}

// optional string token = 5 [default = ""];
inline bool ReqMediaPlay::has_token() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqMediaPlay::set_has_token() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqMediaPlay::clear_has_token() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqMediaPlay::clear_token() {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& ReqMediaPlay::token() const {
  // @@protoc_insertion_point(field_get:com.arges.file.proto.ReqMediaPlay.token)
  return *token_;
}
inline void ReqMediaPlay::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set:com.arges.file.proto.ReqMediaPlay.token)
}
inline void ReqMediaPlay::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.arges.file.proto.ReqMediaPlay.token)
}
inline void ReqMediaPlay::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.arges.file.proto.ReqMediaPlay.token)
}
inline ::std::string* ReqMediaPlay::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.arges.file.proto.ReqMediaPlay.token)
  return token_;
}
inline ::std::string* ReqMediaPlay::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReqMediaPlay::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.arges.file.proto.ReqMediaPlay.token)
}

// optional string ip = 6 [default = ""];
inline bool ReqMediaPlay::has_ip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReqMediaPlay::set_has_ip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReqMediaPlay::clear_has_ip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReqMediaPlay::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& ReqMediaPlay::ip() const {
  // @@protoc_insertion_point(field_get:com.arges.file.proto.ReqMediaPlay.ip)
  return *ip_;
}
inline void ReqMediaPlay::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:com.arges.file.proto.ReqMediaPlay.ip)
}
inline void ReqMediaPlay::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.arges.file.proto.ReqMediaPlay.ip)
}
inline void ReqMediaPlay::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.arges.file.proto.ReqMediaPlay.ip)
}
inline ::std::string* ReqMediaPlay::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.arges.file.proto.ReqMediaPlay.ip)
  return ip_;
}
inline ::std::string* ReqMediaPlay::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReqMediaPlay::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.arges.file.proto.ReqMediaPlay.ip)
}

// optional int32 port = 7 [default = 0];
inline bool ReqMediaPlay::has_port() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReqMediaPlay::set_has_port() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReqMediaPlay::clear_has_port() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReqMediaPlay::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 ReqMediaPlay::port() const {
  // @@protoc_insertion_point(field_get:com.arges.file.proto.ReqMediaPlay.port)
  return port_;
}
inline void ReqMediaPlay::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:com.arges.file.proto.ReqMediaPlay.port)
}

// optional int32 result = 8 [default = -1];
inline bool ReqMediaPlay::has_result() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReqMediaPlay::set_has_result() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReqMediaPlay::clear_has_result() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReqMediaPlay::clear_result() {
  result_ = -1;
  clear_has_result();
}
inline ::google::protobuf::int32 ReqMediaPlay::result() const {
  // @@protoc_insertion_point(field_get:com.arges.file.proto.ReqMediaPlay.result)
  return result_;
}
inline void ReqMediaPlay::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:com.arges.file.proto.ReqMediaPlay.result)
}

// optional bytes resultDescribe = 9 [default = ""];
inline bool ReqMediaPlay::has_resultdescribe() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ReqMediaPlay::set_has_resultdescribe() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ReqMediaPlay::clear_has_resultdescribe() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ReqMediaPlay::clear_resultdescribe() {
  if (resultdescribe_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resultdescribe_->clear();
  }
  clear_has_resultdescribe();
}
inline const ::std::string& ReqMediaPlay::resultdescribe() const {
  // @@protoc_insertion_point(field_get:com.arges.file.proto.ReqMediaPlay.resultDescribe)
  return *resultdescribe_;
}
inline void ReqMediaPlay::set_resultdescribe(const ::std::string& value) {
  set_has_resultdescribe();
  if (resultdescribe_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resultdescribe_ = new ::std::string;
  }
  resultdescribe_->assign(value);
  // @@protoc_insertion_point(field_set:com.arges.file.proto.ReqMediaPlay.resultDescribe)
}
inline void ReqMediaPlay::set_resultdescribe(const char* value) {
  set_has_resultdescribe();
  if (resultdescribe_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resultdescribe_ = new ::std::string;
  }
  resultdescribe_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.arges.file.proto.ReqMediaPlay.resultDescribe)
}
inline void ReqMediaPlay::set_resultdescribe(const void* value, size_t size) {
  set_has_resultdescribe();
  if (resultdescribe_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resultdescribe_ = new ::std::string;
  }
  resultdescribe_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.arges.file.proto.ReqMediaPlay.resultDescribe)
}
inline ::std::string* ReqMediaPlay::mutable_resultdescribe() {
  set_has_resultdescribe();
  if (resultdescribe_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resultdescribe_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.arges.file.proto.ReqMediaPlay.resultDescribe)
  return resultdescribe_;
}
inline ::std::string* ReqMediaPlay::release_resultdescribe() {
  clear_has_resultdescribe();
  if (resultdescribe_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = resultdescribe_;
    resultdescribe_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReqMediaPlay::set_allocated_resultdescribe(::std::string* resultdescribe) {
  if (resultdescribe_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete resultdescribe_;
  }
  if (resultdescribe) {
    set_has_resultdescribe();
    resultdescribe_ = resultdescribe;
  } else {
    clear_has_resultdescribe();
    resultdescribe_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.arges.file.proto.ReqMediaPlay.resultDescribe)
}

// -------------------------------------------------------------------

// ReqTokenPair

// optional string userdata = 1 [default = ""];
inline bool ReqTokenPair::has_userdata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqTokenPair::set_has_userdata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqTokenPair::clear_has_userdata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqTokenPair::clear_userdata() {
  if (userdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userdata_->clear();
  }
  clear_has_userdata();
}
inline const ::std::string& ReqTokenPair::userdata() const {
  // @@protoc_insertion_point(field_get:com.arges.file.proto.ReqTokenPair.userdata)
  return *userdata_;
}
inline void ReqTokenPair::set_userdata(const ::std::string& value) {
  set_has_userdata();
  if (userdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userdata_ = new ::std::string;
  }
  userdata_->assign(value);
  // @@protoc_insertion_point(field_set:com.arges.file.proto.ReqTokenPair.userdata)
}
inline void ReqTokenPair::set_userdata(const char* value) {
  set_has_userdata();
  if (userdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userdata_ = new ::std::string;
  }
  userdata_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.arges.file.proto.ReqTokenPair.userdata)
}
inline void ReqTokenPair::set_userdata(const char* value, size_t size) {
  set_has_userdata();
  if (userdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userdata_ = new ::std::string;
  }
  userdata_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.arges.file.proto.ReqTokenPair.userdata)
}
inline ::std::string* ReqTokenPair::mutable_userdata() {
  set_has_userdata();
  if (userdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userdata_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.arges.file.proto.ReqTokenPair.userdata)
  return userdata_;
}
inline ::std::string* ReqTokenPair::release_userdata() {
  clear_has_userdata();
  if (userdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = userdata_;
    userdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReqTokenPair::set_allocated_userdata(::std::string* userdata) {
  if (userdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete userdata_;
  }
  if (userdata) {
    set_has_userdata();
    userdata_ = userdata;
  } else {
    clear_has_userdata();
    userdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.arges.file.proto.ReqTokenPair.userdata)
}

// -------------------------------------------------------------------

// RspTokenPair

// optional string ip = 1 [default = ""];
inline bool RspTokenPair::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RspTokenPair::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RspTokenPair::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RspTokenPair::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& RspTokenPair::ip() const {
  // @@protoc_insertion_point(field_get:com.arges.file.proto.RspTokenPair.ip)
  return *ip_;
}
inline void RspTokenPair::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:com.arges.file.proto.RspTokenPair.ip)
}
inline void RspTokenPair::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.arges.file.proto.RspTokenPair.ip)
}
inline void RspTokenPair::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.arges.file.proto.RspTokenPair.ip)
}
inline ::std::string* RspTokenPair::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.arges.file.proto.RspTokenPair.ip)
  return ip_;
}
inline ::std::string* RspTokenPair::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RspTokenPair::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.arges.file.proto.RspTokenPair.ip)
}

// optional int32 port = 2 [default = -1];
inline bool RspTokenPair::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RspTokenPair::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RspTokenPair::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RspTokenPair::clear_port() {
  port_ = -1;
  clear_has_port();
}
inline ::google::protobuf::int32 RspTokenPair::port() const {
  // @@protoc_insertion_point(field_get:com.arges.file.proto.RspTokenPair.port)
  return port_;
}
inline void RspTokenPair::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:com.arges.file.proto.RspTokenPair.port)
}

// optional string token1 = 3 [default = ""];
inline bool RspTokenPair::has_token1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RspTokenPair::set_has_token1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RspTokenPair::clear_has_token1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RspTokenPair::clear_token1() {
  if (token1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token1_->clear();
  }
  clear_has_token1();
}
inline const ::std::string& RspTokenPair::token1() const {
  // @@protoc_insertion_point(field_get:com.arges.file.proto.RspTokenPair.token1)
  return *token1_;
}
inline void RspTokenPair::set_token1(const ::std::string& value) {
  set_has_token1();
  if (token1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token1_ = new ::std::string;
  }
  token1_->assign(value);
  // @@protoc_insertion_point(field_set:com.arges.file.proto.RspTokenPair.token1)
}
inline void RspTokenPair::set_token1(const char* value) {
  set_has_token1();
  if (token1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token1_ = new ::std::string;
  }
  token1_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.arges.file.proto.RspTokenPair.token1)
}
inline void RspTokenPair::set_token1(const char* value, size_t size) {
  set_has_token1();
  if (token1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token1_ = new ::std::string;
  }
  token1_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.arges.file.proto.RspTokenPair.token1)
}
inline ::std::string* RspTokenPair::mutable_token1() {
  set_has_token1();
  if (token1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token1_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.arges.file.proto.RspTokenPair.token1)
  return token1_;
}
inline ::std::string* RspTokenPair::release_token1() {
  clear_has_token1();
  if (token1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = token1_;
    token1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RspTokenPair::set_allocated_token1(::std::string* token1) {
  if (token1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete token1_;
  }
  if (token1) {
    set_has_token1();
    token1_ = token1;
  } else {
    clear_has_token1();
    token1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.arges.file.proto.RspTokenPair.token1)
}

// optional string token2 = 4 [default = ""];
inline bool RspTokenPair::has_token2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RspTokenPair::set_has_token2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RspTokenPair::clear_has_token2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RspTokenPair::clear_token2() {
  if (token2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token2_->clear();
  }
  clear_has_token2();
}
inline const ::std::string& RspTokenPair::token2() const {
  // @@protoc_insertion_point(field_get:com.arges.file.proto.RspTokenPair.token2)
  return *token2_;
}
inline void RspTokenPair::set_token2(const ::std::string& value) {
  set_has_token2();
  if (token2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token2_ = new ::std::string;
  }
  token2_->assign(value);
  // @@protoc_insertion_point(field_set:com.arges.file.proto.RspTokenPair.token2)
}
inline void RspTokenPair::set_token2(const char* value) {
  set_has_token2();
  if (token2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token2_ = new ::std::string;
  }
  token2_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.arges.file.proto.RspTokenPair.token2)
}
inline void RspTokenPair::set_token2(const char* value, size_t size) {
  set_has_token2();
  if (token2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token2_ = new ::std::string;
  }
  token2_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.arges.file.proto.RspTokenPair.token2)
}
inline ::std::string* RspTokenPair::mutable_token2() {
  set_has_token2();
  if (token2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token2_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.arges.file.proto.RspTokenPair.token2)
  return token2_;
}
inline ::std::string* RspTokenPair::release_token2() {
  clear_has_token2();
  if (token2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = token2_;
    token2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RspTokenPair::set_allocated_token2(::std::string* token2) {
  if (token2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete token2_;
  }
  if (token2) {
    set_has_token2();
    token2_ = token2;
  } else {
    clear_has_token2();
    token2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.arges.file.proto.RspTokenPair.token2)
}

// optional int32 result = 5 [default = -1];
inline bool RspTokenPair::has_result() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RspTokenPair::set_has_result() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RspTokenPair::clear_has_result() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RspTokenPair::clear_result() {
  result_ = -1;
  clear_has_result();
}
inline ::google::protobuf::int32 RspTokenPair::result() const {
  // @@protoc_insertion_point(field_get:com.arges.file.proto.RspTokenPair.result)
  return result_;
}
inline void RspTokenPair::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:com.arges.file.proto.RspTokenPair.result)
}

// optional string userdata = 6 [default = ""];
inline bool RspTokenPair::has_userdata() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RspTokenPair::set_has_userdata() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RspTokenPair::clear_has_userdata() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RspTokenPair::clear_userdata() {
  if (userdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userdata_->clear();
  }
  clear_has_userdata();
}
inline const ::std::string& RspTokenPair::userdata() const {
  // @@protoc_insertion_point(field_get:com.arges.file.proto.RspTokenPair.userdata)
  return *userdata_;
}
inline void RspTokenPair::set_userdata(const ::std::string& value) {
  set_has_userdata();
  if (userdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userdata_ = new ::std::string;
  }
  userdata_->assign(value);
  // @@protoc_insertion_point(field_set:com.arges.file.proto.RspTokenPair.userdata)
}
inline void RspTokenPair::set_userdata(const char* value) {
  set_has_userdata();
  if (userdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userdata_ = new ::std::string;
  }
  userdata_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.arges.file.proto.RspTokenPair.userdata)
}
inline void RspTokenPair::set_userdata(const char* value, size_t size) {
  set_has_userdata();
  if (userdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userdata_ = new ::std::string;
  }
  userdata_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.arges.file.proto.RspTokenPair.userdata)
}
inline ::std::string* RspTokenPair::mutable_userdata() {
  set_has_userdata();
  if (userdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userdata_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.arges.file.proto.RspTokenPair.userdata)
  return userdata_;
}
inline ::std::string* RspTokenPair::release_userdata() {
  clear_has_userdata();
  if (userdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = userdata_;
    userdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RspTokenPair::set_allocated_userdata(::std::string* userdata) {
  if (userdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete userdata_;
  }
  if (userdata) {
    set_has_userdata();
    userdata_ = userdata;
  } else {
    clear_has_userdata();
    userdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.arges.file.proto.RspTokenPair.userdata)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace file
}  // namespace arges
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::com::arges::file::proto::ACCESS_TYPE_OF_DEVICE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::arges::file::proto::ACCESS_TYPE_OF_DEVICE>() {
  return ::com::arges::file::proto::ACCESS_TYPE_OF_DEVICE_descriptor();
}
template <> struct is_proto_enum< ::com::arges::file::proto::STREAM_TYPE_OF_MEDIA> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::arges::file::proto::STREAM_TYPE_OF_MEDIA>() {
  return ::com::arges::file::proto::STREAM_TYPE_OF_MEDIA_descriptor();
}
template <> struct is_proto_enum< ::com::arges::file::proto::REQUEST_TYPE_OF_MEIDA> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::arges::file::proto::REQUEST_TYPE_OF_MEIDA>() {
  return ::com::arges::file::proto::REQUEST_TYPE_OF_MEIDA_descriptor();
}
template <> struct is_proto_enum< ::com::arges::file::proto::RESULT_TYPE_OF_MEDIA> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::arges::file::proto::RESULT_TYPE_OF_MEDIA>() {
  return ::com::arges::file::proto::RESULT_TYPE_OF_MEDIA_descriptor();
}
template <> struct is_proto_enum< ::com::arges::file::proto::OPRATE_TYPE_OF_MEDIA> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::arges::file::proto::OPRATE_TYPE_OF_MEDIA>() {
  return ::com::arges::file::proto::OPRATE_TYPE_OF_MEDIA_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MediaBean_2eproto__INCLUDED
